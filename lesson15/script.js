//! асинхронность в JS
// мы писали до этого синхронный код
// он срабатывает последовательно по порядку сверху вниз
// но в JS мы имеем возможность работать с кодом, выполнение которого будет откладываться
// ниже рассмотрим примеры асинхронности в JS

// ? setTimeout()

// откладывает выполнение кода на заданное время
// принимает два аргумента:
// 1. функцию с кодом, котораясработает после истечения заданного времени
// 2. время в млсек

// console.log('Начало!')

setTimeout(() => {
    //console.log('Прошло 5 секунд!');
}, 5000);

//console.log('конец!');

// ! любой асинхронный код сработает позже синхронного кода
// даже если в setTimeout указать 0 сек

// ? setInterval()

// задает повторное выполнение кода

// 1.м аргументом принимает функцию с описанием действия
// 2.м аргументом - значение времени, через которое действие сработает в млсек

// интервал будет повторяться до тех пор, пока мы его не остановим
// ддля того, чтобы его остановить в будущем мы кладем ссылку на него в переменную

const interval = setInterval(() => {
    //console.log('Tick!');
}, 2000);

// чтобы остановить  interval мы применяем к нему метод clearInterval()

setTimeout(() => {
    clearInterval(interval)
}, 7000);

// это действие синхронное, поэтому оно сработает раньше, чем setTimeout() & setInterval()
//console.log('P.S.');

// ! async request & promises

// API - Application Programming Interface
// набор правил, позволяющий одним программам понимать другие прошраммы, 
// общаясь ддруг с другом и обмениваться данными

// часто, когда мы работаем с API, мы хотим сделать запрос данных, чтобы обработать их 
// в своем коде и отобразить их на странице

// * если я хочу подучить удаленные данные по запросу, то используем ключевое слово fetch() (принеси)

// в ответ на запрос получаем данные в виде объекта - Promise

// Promise - это особый вид данных в JS, который нуждается в асинхронной обработке.
// у него есть три состояния:
// 1. <Pending> - ожидание данных
// 2. <Fulfilled> - данные успешно пришли
// 3. <Rejected> - данные пришли с ошибкой

// ? запрос не получится обработать синхронно

//const data = fetch('https://dog.ceo/api/breads/image/random')
//console.log('data');

// ? чтобы обработать асинхронный запрос, возращающий объект Promise, мы используем метод then()

// ! короткий fetch запрос расчитанный только на успех

// fetch("https://dog.seo/api/bread")
// .then((res) => res.json())
// .then((data) => {
//     const img = document.createElement('img');
//     img.src = data.message;
//     document.body.append(img);
// })

// ! длинный fetch запрос обрабатывающий ошибку

// запрос данных возращающий Promise, который обрабатываем через then()
fetch("https://dog.ceo/api/breads/image/random")
.then((res) => {
    //если поле ok - в положении false переходит к блоку .catch - обрабатыващий ошибку
    if (!res.ok) {
        throw new Error(`Ошибка: ${res.status}`);
    }
    return res.json()
})
// если все хорошо, обрабатываем данные
.then((data) => {
    const img = document.createElement('img');
    img.src = data.message;
    document.body.append(img);
})
// если ошибка, показываем ее в консоле
.catch((error) => {
    const h2 = document.createElement('h2');
    h2.src = error;
    document.body.append(error);
    console.log(error)
});
